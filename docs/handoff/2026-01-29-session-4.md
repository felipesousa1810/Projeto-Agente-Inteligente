# Handoff Note - Session 4
**Data:** 2026-01-29
**Autor:** Antigravity (Agent)

## 1. TRABALHO CONCLUÍDO

### Integração e Verificação
- **Google Calendar Auth:** Implementado fluxo de autenticação híbrido para credenciais "Web Client" (OAuth).
    - Criado `src/scripts/auth_google.py` para gerar `token.json` localmente.
    - Atualizado `src/services/calendar.py` para carregar token da variável de ambiente `GOOGLE_TOKEN_JSON` (facilitando deploy no EasyPanel).
- **Supabase:** Verificado e validado `schema.sql` e políticas RLS (`src/db/rls_policies.sql`).
- **Evolution API:** Webhook endpoint validado em `src/handlers/webhook.py`.

### Debugging e Correções (CI/CD & Runtime)
- **Erro de Runtime `pydantic-ai`:** Resolvido erro `Unknown keyword arguments: result_type` no EasyPanel.
    - **Causa:** Versão antiga da lib instalada no servidor.
    - **Solução:** Atualizado `pyproject.toml` para `pydantic-ai>=0.0.24` e revertido código para usar `output_type` (padrão oficial).
- **Erro de Mypy (CI):** Resolvido falso positivo "Unexpected keyword argument 'output_type'".
    - **Solução:** Adicionado `# type: ignore` na instanciação do `Agent` em `nlu.py` e `nlg.py`.

### Arquivos Modificados
- `pyproject.toml`: Bump de versão `pydantic-ai`.
- `src/core/nlu.py`: Fix `output_type` + suppressão de tipo.
- `src/core/nlg.py`: Fix `output_type` + suppressão de tipo.
- `src/services/calendar.py`: Suporte a token via env var.
- `src/scripts/auth_google.py`: [NOVO] Script de auth local.
- `credentials.json`: [NOVO] Credenciais OAuth (Gitignore deve ser verificado, mas salvo localmente para uso).

## 2. ESTADO ATUAL

- **Status do Agente:** ✅ Funcional e Deployed (Versão 1.0.0).
- **Status do CI:** ✅ Passando (com supressões pontuais).
- **Integração:**
    - **NLU/NLG:** Operando com `gpt-4.1-mini-2025-04-14`.
    - **Banco:** Supabase conectado e seguro (RLS ativo para Backend).
    - **Calendar:** Configurado para usar token persistente via ENV.
- **Limitações Conhecidas:**
    - O token do Google Calendar precisa ser renovado se o refresh token expirar (raro, mas possível). O script local resolve isso.

## 3. PRÓXIMOS PASSOS

1.  **Smoke Test em Produção (Imediato):**
    - Enviar mensagens reais no WhatsApp para validar o fluxo completo (Agendamento, Consulta, Cancelamento).
2.  **Monitoramento:**
    - Observar logs no EasyPanel para erros de "Rate Limit" ou timeouts da OpenAI.
    - Verificar tabela `dead_letter_queue` no Supabase.
3.  **Frontend (Futuro):**
    - Implementar Dashboard Administrativo (React/Next.js) consumindo as tabelas do Supabase (já preparadas com RLS).

## 4. CONTEXTO IMPORTANTE

- **Arquitetura Determinística:** O agente NÃO usa LLM para decidir fluxo. Usa `pydantic-ai` apenas para extrair intenção (NLU) e humanizar resposta (NLG). A lógica de negócio está em Python puro (`DecisionEngine`).
- **Versão Pydantic-AI:** Estamos usando `output_type` ao invés de `result_type`. Mantenha `pyproject.toml` atualizado para evitar que o servidor baixe versões arcaicas (0.0.12).
- **Environment:** O `GOOGLE_TOKEN_JSON` é um JSON stringificado colocado na variável de ambiente do EasyPanel. Isso evita subir arquivos sensíveis via Git.

## 5. TRECHOS DE CÓDIGO CRÍTICOS

### Instanciação do Agente (NLU/NLG)
Em `src/core/nlu.py`:
```python
agent: Agent[None, NLUOutput] = Agent(
    model=model,
    # IMPORTANTE: Use output_type, não result_type. Mantenha type: ignore se o mypy reclamar.
    output_type=NLUOutput,  # type: ignore
    system_prompt=NLU_SYSTEM_PROMPT,
    retries=1,
)
```

### Carregamento Híbrido de Token Google
Em `src/services/calendar.py`:
```python
# Tenta carregar do ENV primeiro (Produção)
token_json = os.getenv("GOOGLE_TOKEN_JSON")
if token_json:
    creds = Credentials.from_authorized_user_info(json.loads(token_json), SCOPES)
# Fallback para arquivo local (Desenvolvimento)
elif os.path.exists("token.json"):
    creds = Credentials.from_authorized_user_file("token.json", SCOPES)
```
