# Handoff Note - Session 5: Guardrails & Smart Agent Architecture ðŸ›¡ï¸ðŸ¤–

**Data:** 31/01/2026
**Autor:** Antigravity (Assistant)
**Status:** âœ… Sucesso (RefatoraÃ§Ã£o Completa)

---

## 1. TRABALHO CONCLUÃDO
Nesta sessÃ£o, pivotamos a arquitetura do agente de um modelo determinÃ­stico baseado em templates rÃ­gidos para uma arquitetura **"Agentic Guardrails"** baseada em PydanticAI, inspirada nos padrÃµes de Eugene Yan e Chip Huyen.

### Arquivos Criados/Modificados
*   **`src/core/guardrails.py`:** [NOVO] Define os modelos Pydantic (`ResponseGuardrail`) que servem como contratos de estrutura para as respostas do agente.
    *   Ex: `ConfirmAppointment` obriga o agente a preencher `date`, `time` e `procedure`.
*   **`src/core/nlg.py`:** [REFATORADO] Reescrevi completamente para ser um `ResponseGenerator`.
    *   Agora usa `gpt-4o-mini` para gerar respostas naturais que obedecem estritamente aos modelos do `guardrails.py`.
    *   Substitui o antigo "humanizador" de templates.
*   **`src/core/agent.py`:** [MODIFICADO] Atualizado para usar `generate_response(action)` em vez de `format_template`.
*   **`src/core/templates.py`:** [LIMPEZA] Removido o dicionÃ¡rio `TEMPLATES`. Mantido apenas `FAQ_KNOWLEDGE` como base de conhecimento estÃ¡tica.
*   **`.gemini/.../advanced_capabilities.md`:** [NOVO] Roadmap tÃ©cnico de padrÃµes avanÃ§ados (RAG, Deps Clean, etc).

### Testes
*   `ruff check` e `ruff format` passaram em todos os arquivos novos.
*   `mypy` passou (apÃ³s correÃ§Ã£o de regressÃ£o `.data` -> `.output`).

## 2. ESTADO ATUAL
*   **Funcionalidade:** O agente continua capaz de agendar, consultar e cancelar, mas agora suas respostas sÃ£o geradas criativamente por LLM dentro de trilhos seguros.
*   **SeguranÃ§a:** A estrutura das respostas Ã© garantida por validaÃ§Ã£o Pydantic. ImpossÃ­vel o agente "esquecer" a data num pedido de confirmaÃ§Ã£o.
*   **LimitaÃ§Ã£o Conhecida:** O conhecimento de FAQ (`FAQ_KNOWLEDGE`) ainda Ã© um dicionÃ¡rio estÃ¡tico.
*   **DependÃªncias:** O cÃ³digo ainda usa Singletons globais (`_agent`, `_decision_engine`), dificultando testes unitÃ¡rios isolados.

## 3. PRÃ“XIMOS PASSOS (Roadmap Imediato)
RecomendaÃ§Ã£o forte para seguir o plano em `advanced_capabilities.md`:

1.  **InjeÃ§Ã£o de DependÃªncias (Prioridade Alta):**
    *   Refatorar `Agent` para usar `deps_type` do PydanticAI.
    *   Eliminar globais (`src/services` imports diretos).
    *   PermitirÃ¡ testes com banco de dados mockado.
2.  **Implementar RAG (Retrieval-Augmented Generation):**
    *   Substituir `FAQ_KNOWLEDGE` por uma ferramenta de busca vetorial (Supabase pgvector).
    *   Isso permitirÃ¡ ao agente responder perguntas complexas sobre a clÃ­nica baseando-se em documentos reais.
3.  **Melhorar Testes:**
    *   Escrever testes usando `TestAgent` do PydanticAI para validar fluxos de conversa sem custo de API.

## 4. CONTEXTO IMPORTANTE
*   **Filosofia "Smart Rails":** O cÃ³digo decide *o que* fazer (Decision Engine determinÃ­stico), mas o LLM decide *como* falar (NLG com Guardrails).
*   **Qualidade de CÃ³digo:** Estamos enforceando `ruff` rigorosamente. Cuidado com `N805` (falta de `cls`/`self` em validadores) e tipagem correta do PydanticAI (`result.output`).
*   **Pre-commit:** Bloqueia commits se houver erro de linter. Rode `ruff check .` antes de commitar.

## 5. TRECHOS DE CÃ“DIGO CRÃTICOS

**Como funciona a geraÃ§Ã£o segura (`src/core/nlg.py`):**
```python
# Mapeia a AÃ§Ã£o -> Guardrails (Contrato)
target_model = _get_model_for_action(action.action_type)

# LLM gera respeitando o contrato
result = await self.agent.run(
    prompt,
    result_type=target_model, # O segredo estÃ¡ aqui!
)
```

**Novo Validador com correÃ§Ã£o de Linter (`src/core/guardrails.py`):**
```python
@field_validator("message")
@classmethod  # ObrigatÃ³rio para validadores de campo
def validate_question_mark(cls, v: str) -> str:
    if "?" not in v:
        raise ValueError("Must contain '?'")
    return v
```
